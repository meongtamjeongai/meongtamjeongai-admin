# .github/workflows/deploy-admin-app.yml

name: Deploy Admin App to NAT Instance (Manual Trigger)

on:
  workflow_dispatch:
    inputs:
      git_ref:
        description: '빌드할 Git 참조 (브랜치, 태그 또는 커밋 SHA)'
        required: true
        default: 'main'

permissions:
  id-token: write
  contents: read

env:
  # ------------------------------------------------------------------
  # ⚙️ 이 워크플로우가 사용할 환경 변수들 (GitHub Secrets에서 가져옴)
  # ------------------------------------------------------------------
  AWS_REGION: ${{ secrets.AWS_REGION }}
  # ⭐️ 관리자 앱 전용 ECR 리포지토리 이름을 사용하도록 명확화
  ADMIN_ECR_REPOSITORY: ${{ secrets.ADMIN_ECR_REPOSITORY }}
  # ⭐️ 관리자 앱 컨테이너 이름 지정
  ADMIN_CONTAINER_NAME: meongtamjeong-admin-app
  # ⭐️ 관리자 앱이 호스트와 컨테이너에서 사용할 포트
  ADMIN_HOST_PORT: 8501
  ADMIN_CONTAINER_PORT: 8501

jobs:
  build-and-deploy-admin-app:
    name: Build, Push Admin App to ECR, and Deploy to NAT Instance
    runs-on: ubuntu-latest

    steps:
      # 1. 소스 코드 체크아웃
      - name: Checkout source code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.inputs.git_ref }}

      # 2. AWS 자격 증명 설정 (OIDC 방식)
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_TO_ASSUME_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      # 3. Amazon ECR 로그인
      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      # 4. Docker 이미지 빌드 및 ECR에 푸시
      - name: Build, tag, and push admin image to Amazon ECR
        id: build-and-push-image
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          docker build -t ${{ env.ECR_REGISTRY }}/${{ env.ADMIN_ECR_REPOSITORY }}:${{ env.IMAGE_TAG }} .
          docker push ${{ env.ECR_REGISTRY }}/${{ env.ADMIN_ECR_REPOSITORY }}:${{ env.IMAGE_TAG }}
      
      # 5. SSM Send-Command를 통해 NAT 인스턴스에 배포
      - name: Deploy to NAT instance via SSM Run Command
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ github.sha }}
          SECRET_SIGNUP_MODE_VALUE: ${{ secrets.SECRET_SIGNUP_MODE }}
          ALB_DNS_NAME: ${{ secrets.ALB_DNS_NAME }}
        run: |
          set -e
          
          echo "Updating /etc/hosts for internal communication..."
          # dig 명령어로 DNS Name을 Private IP로 해석(resolve)
          ALB_PRIVATE_IP=$(dig +short __ALB_DNS_NAME__ | tail -n1)

          if [ -n "$ALB_PRIVATE_IP" ]; then
            # 기존 meong.shop 항목이 있다면 삭제 후 추가
            sudo sed -i '/meong.shop/d' /etc/hosts
            echo "$ALB_PRIVATE_IP meong.shop admin.meong.shop" | sudo tee -a /etc/hosts
            echo "✅ /etc/hosts updated with IP: $ALB_PRIVATE_IP"
          else
            echo "::error:: Could not resolve ALB DNS Name [__ALB_DNS_NAME__]. /etc/hosts not updated."
            exit 1
          fi

          # 실행할 쉘 스크립트 내용을 변수에 저장 (Here Document)
          # ⭐️ FASTAPI_API_BASE_URL 환경 변수 주입 로직 추가
          COMMAND_SCRIPT=$(cat <<'EOF'
          set -e
          echo "==== [SSM] Logging into ECR from EC2 instance ===="
          aws ecr get-login-password --region __AWS_REGION__ | sudo docker login --username AWS --password-stdin __ECR_REGISTRY__
          
          echo "==== [SSM] Pulling new image: __FULL_IMAGE_URI__ ===="
          sudo docker pull __FULL_IMAGE_URI__
          
          echo "==== [SSM] Stopping and removing old container: __CONTAINER_NAME__ ===="
          if [ $(sudo docker ps -q -f name=__CONTAINER_NAME__) ]; then sudo docker stop __CONTAINER_NAME__; fi
          if [ $(sudo docker ps -aq -f name=__CONTAINER_NAME__) ]; then sudo docker rm __CONTAINER_NAME__; fi
          
          echo "==== [SSM] Starting new container on host port __HOST_PORT__... ===="
          sudo docker run -d \
            --name __CONTAINER_NAME__ \
            -p __HOST_PORT__:__CONTAINER_PORT__ \
            --restart always \
            -e FASTAPI_API_BASE_URL="__FASTAPI_URL__" \
            -e SECRET_SIGNUP_MODE="__SECRET_SIGNUP_MODE__" \
            __FULL_IMAGE_URI__
            
          echo "==== [SSM] Pruning old docker images ===="
          sudo docker image prune -af
          
          echo "==== [SSM] Deployment script finished successfully! ===="
          EOF
          )
          
          # 스크립트 내 플레이스홀더들을 실제 값으로 치환
          FULL_IMAGE_URI="${ECR_REGISTRY}/${ADMIN_ECR_REPOSITORY}:${IMAGE_TAG}"
          COMMAND_SCRIPT="${COMMAND_SCRIPT//__AWS_REGION__/${AWS_REGION}}"
          COMMAND_SCRIPT="${COMMAND_SCRIPT//__ECR_REGISTRY__/${ECR_REGISTRY}}"
          COMMAND_SCRIPT="${COMMAND_SCRIPT//__FULL_IMAGE_URI__/${FULL_IMAGE_URI}}"
          COMMAND_SCRIPT="${COMMAND_SCRIPT//__CONTAINER_NAME__/${ADMIN_CONTAINER_NAME}}"
          COMMAND_SCRIPT="${COMMAND_SCRIPT//__HOST_PORT__/${ADMIN_HOST_PORT}}"
          COMMAND_SCRIPT="${COMMAND_SCRIPT//__CONTAINER_PORT__/${ADMIN_CONTAINER_PORT}}"
          COMMAND_SCRIPT="${COMMAND_SCRIPT//__SECRET_SIGNUP_MODE__/${SECRET_SIGNUP_MODE_VALUE}}"
          COMMAND_SCRIPT="${COMMAND_SCRIPT//__ALB_DNS_NAME__/${ALB_DNS_NAME}}"
          # ⭐️ FastAPI URL 플레이스홀더 치환
          COMMAND_SCRIPT="${COMMAND_SCRIPT//__FASTAPI_URL__/${{ secrets.FASTAPI_BASE_URL }}}"
          
          # jq를 사용하여 SSM 파라미터용 JSON을 안전하게 생성
          SSM_PARAMETERS=$(jq -n --arg script "$COMMAND_SCRIPT" '{ "commands": ($script | split("\n")) }')

          echo "==== [GitHub Actions] Sending deployment command to NAT instance via SSM... ===="
          aws ssm send-command \
            --instance-ids "${{ secrets.NAT_INSTANCE_ID }}" \
            --document-name "AWS-RunShellScript" \
            --comment "Deploy Admin App image tag ${{ env.IMAGE_TAG }} via GitHub Actions" \
            --parameters "$SSM_PARAMETERS"